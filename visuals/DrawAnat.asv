function h = DrawAnat(h)
cIX = h.cIX;

%% plot mean image with ROI's drawn on top.
% mean image
im1_0 = squeeze(h.dat.mimg(:,:,2));

% ROI image
Sat1     =  ones(h.dat.cl.Ly, h.dat.cl.Lx);
Sat2     =  ones(h.dat.cl.Ly, h.dat.cl.Lx);
H1              = zeros(h.dat.cl.Ly, h.dat.cl.Lx);
H2              = zeros(h.dat.cl.Ly, h.dat.cl.Lx);

% chose cells
for i = 1:length(h.dat.stat)
    h.dat.stat(i).iscell = (ismember(i,cIX));
end
%
[iclust1, iclust2, V1, V2] = ...
    getviclust(h.dat.stat, h.dat.cl.Ly,  h.dat.cl.Lx, h.dat.cl.vmap, h.dat.F.ichosen);

% iselect     = iclust1==h.dat.F.ichosen;
% Sat1(iselect)= 0;
%
% iselect     = iclust2==h.dat.F.ichosen;
% Sat2(iselect)= 0;

% % make colormap

if h.clrmaptype == 'hsv' % use HSV coding, which, in the Value channel includes information from 'lambda' (from ROI stats)
numK = length(cIX);
clrmap = linspace(0.05,0.9,numK); % to make a custom hsv map that doesn't include the circular overlap range in magenta-red (by not using range 0 to 1)
clrmap_abs = zeros(1,length(h.dat.stat)); % each cell gets a color, saved into h.clrmap for use across the gui
clrmap_abs(cIX) = clrmap;



% cmap2 = rgb2hsv(clrmap);


% size of clrmap is now 1*numROIs
H1(iclust1>0)   = clrmap_abs(iclust1(iclust1>0)); % size of H1 is X*Y
% H1(iclust1>0)   = h.dat.cl.rands(iclust1(iclust1>0));
% H2(iclust2>0)   = h.dat.cl.rands(iclust2(iclust2>0));

I = hsv2rgb(cat(3, H1, Sat1, V1)); % convert HSV into RGB, size of I is X*Y*3
im_roi = min(I, 1); % make sure no RGB values exceed 1, should all be between 0 and 1

else % use RGB
%     I = zeros(size(im1_0,1),size(im1_0,2),3);
numK = length(cIX);
clrmap = jet(numK);    
clrmap_abs = zeros(1,length(h.dat.stat)); % each cell gets a color, saved into h.clrmap for use across the gui
clrmap_abs(cIX) = clrmap;

% (the following is cumbersome but gets the indexing done)
R = zeros(size(im1_0));
    G = zeros(size(im1_0));
    B = zeros(size(im1_0));
    Rclrmap_abs = clrmaps_abs(:,1);
    Gclrmap_abs = clrmaps_abs(:,2);
    Bclrmap_abs = clrmaps_abs(:,3);
    R(iclust1>0)   = Rclrmap_abs(iclust1(iclust1>0));
    G(iclust1>0)   = Gclrmap_abs(iclust1(iclust1>0));
    B(iclust1>0)   = Bclrmap_abs(iclust1(iclust1>0));
    im_roi = cat(3,R,G,B);
end

inew = find(H1>0); % these are the colored pixels that need to be drawn on top of the black and white anat background
% combine and draw
im1_1 = mat2gray(im1_0);
im1 = repmat(im1_1,1,1,3); 
Low_High  = [0,0.5];
im1 = imadjust(im1,Low_High); % im1: grayscale background, in RGB

im_anat = im1; %(im1+im2)/2; % im2: the color image; ?? obsl
im_anat(inew) = im_roi(inew); % draw colors again in R channel,...
numpix = numel(H1);
im_anat(inew+numpix) = im_roi(inew+numpix); % ...in Green channel,
im_anat(inew+2*numpix) = im_roi(inew+2*numpix); % ... and in Blue channel


h.im_anat = im_anat; % output
h.clrmap = clrmap_abs;

end